# Internationalization (i18n) Documentation

## Overview
Internationalization is handled through a custom `useTranslation` hook that provides translations for all user-facing text. The system supports multiple languages with JSON-based translation files.
All translations calls lowercase with no separators like dot, dashes or underscores.

## Architecture Pattern

### Translation Context
The translation system uses React Context to provide translations:

```typescript
// In context/TranslationContext.tsx
export interface TranslationContextProps {
    t: (arg0: string, replacements?: string[]) => string,
    locale: LangsEnum
}
```

### Translation Hook
The `useTranslation` hook provides access to translations:

```typescript
const { t, locale } = useTranslation();

// Usage in components
<h1>{t('welcome')}</h1>
<Button>{t('submit')}</Button>
```

### Supported Languages
Languages are defined in [`src/enums/LangsEnum.ts`](web/src/enums/LangsEnum.ts):

```typescript
export enum LangsEnum {
    PT = 'pt', 
    EN = 'en'
}
```

## Usage Patterns

### Basic Translation
```typescript
// Simple key
const message = t('submit');

// Nested key
const message = t('validation.required');
```

### Translation with Parameters
Replacements use the `#?` placeholder:

```typescript
// In translation file: "welcome user": "Welcome, #?"
const message = t('welcome user', [userName]);
```

### Accessing Locale
```typescript
const { t, locale } = useTranslation();

// Use locale for formatting
const formattedDate = new Date().toLocaleDateString(locale);
```

## Integration with Forms

### Form Labels
```tsx
<FormField
  control={form.control}
  name="email"
  render={({ field }) => (
    <FormItem>
      <FormLabel>{t('email')}</FormLabel>
      <FormControl>
        <Input placeholder={t('placeholder.email')} {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Validation Messages
TypeBox resolver uses locale for validation messages:
```typescript
const form = useForm({
  resolver: typeboxResolver(formSchema, { locale }),
});
```

### Button Text
```tsx
<Button type="submit" disabled={isLoading}>
  {isLoading ? t('signing in') + "..." : t('sign in')}
</Button>
```

## Language Management

### Language Detection
Language can be detected from:
- Browser settings
- User preferences (stored in cookies via js-cookie)
- URL path
- Server-side configuration

### Language Switching
The `useLanguage` hook handles language switching:

```typescript
// In hooks/useLanguage.ts
const { currentLocale, changeLanguage, supportedLocales } = useLanguage();

// Switch language
<button onClick={() => changeLanguage(LangsEnum.PT)}>
  {t('portuguese')}
</button>
```

### Theme Integration
Language is persisted alongside theme using js-cookie:

```typescript
// In hooks/useTheme.ts
Cookies.set('theme', theme)

// In hooks/useLanguage.ts
Cookies.set('lang', newLocale)
```

## Provider Setup

### TranslationProvider
Wrap your application with the TranslationProvider:

```tsx
// In app layout or providers
<TranslationProvider translation={translations} locale={currentLocale}>
  {children}
</TranslationProvider>
```

### Nested Providers
Multiple context providers can be nested:

```tsx
function App() {
  return (
    <AuthProvider>
      <QueryProvider>
        <ThemeProvider>
          <TranslationProvider>
            <RouterProvider />
          </TranslationProvider>
        </ThemeProvider>
      </QueryProvider>
    </AuthProvider>
  );
}
```

## Translation Files

### File Structure
Translation files are stored as JSON:
```
locales/
├── en/
│   └── common.json
└── pt/
    └── common.json
```

### Translation File Structure
```json
{
  "welcome": "Welcome",
  "sign in": "Sign in",
  "signing in": "Signing in",
  "email": "Email",
  "password": "Password",
  "submit": "Submit",
  "cancel": "Cancel",
  "loading": "Loading...",
  "error": "An error occurred",
  "validation": {
    "required": "This field is required",
    "email": "Invalid email address"
  },
  "welcome user": "Welcome, #?"
}
```

## Best Practices
- Use translation keys for ALL user-facing text
- Avoid hardcoding strings in components
- Use descriptive, semantic translation keys
- Group related translations logically
- Provide fallback values for missing translations
- Use array parameters `#?` for dynamic content
- Consider text length differences across languages
- Test UI with longer translations
- Keep translation files organized by feature or page
- Use consistent naming conventions for keys
